# Arborescence du dépôt

  - .gitignore
  - README.md
  - combined_output.txt
  - generate_single_file.py
  - hacs.json
  - custom_components/
    - custom_components/urbansolar_battery/
      - __init__.py
      - config_flow.py
      - const.py
      - copy_yaml_files.py
      - manifest.json
      - sensor.py
      - setup_virtual_battery.py
      - custom_components/urbansolar_battery/config/
        - automations.yaml
        - input_numbers.yaml
        - lovelace.yaml
        - sensors.yaml
        - utility_meters.yaml
      - custom_components/urbansolar_battery/translations/
        - fr.json
  - .github/
  - .git/
  - documentation/
    - instructions.md

---


---
# .gitignore
---

# Fichiers sensibles Home Assistant
.alert
.history/
 Ago
.custom_components/ 
.scripts/
# Autres excludes
node_modules/
.DS_Store
*.pyc
*.txt

---
# generate_single_file.py
---

import os

OUTPUT_FILE = "combined_output.txt"
IGNORED_DIRS = {".git", ".github", "__pycache__", "venv", "node_modules"}
IGNORED_CONTENT_EXTENSIONS = {".md"}  # <--- Exclure ces fichiers du contenu détaillé
IGNORED_BINARY_EXTENSIONS = {".png", ".jpg", ".jpeg", ".gif", ".exe", ".zip", ".tar", ".gz", ".7z"}

def should_ignore_dir(path):
    for ignored in IGNORED_DIRS:
        if f"/{ignored}/" in path.replace("\\", "/"):
            return True
    return False

def build_filetree():
    tree_lines = []
    for root, dirs, files in os.walk("."):
        if should_ignore_dir(root):
            continue
        indent = "  " * (root.count(os.sep))
        rel_root = os.path.relpath(root, ".")
        if rel_root != ".":
            tree_lines.append(f"{indent}- {rel_root}/")
        for file in sorted(files):
            full_path = os.path.join(root, file)
            if should_ignore_dir(full_path):
                continue
            tree_indent = "  " * (full_path.count(os.sep))
            tree_lines.append(f"{tree_indent}- {file}")
    return "\n".join(tree_lines)

def should_include_in_content(path):
    ext = os.path.splitext(path)[1].lower()
    if ext in IGNORED_BINARY_EXTENSIONS:
        return False
    if ext in IGNORED_CONTENT_EXTENSIONS:
        return False
    return True

def main():
    content_parts = []

    # 1. Filetree en tête
    filetree = build_filetree()
    content_parts.append("# Arborescence du dépôt\n\n")
    content_parts.append(filetree)
    content_parts.append("\n\n---\n")

    # 2. Contenu détaillé
    for root, dirs, files in os.walk("."):
        for file in sorted(files):
            full_path = os.path.join(root, file)
            if full_path.startswith("./" + OUTPUT_FILE):
                continue
            if should_ignore_dir(full_path):
                continue
            if not should_include_in_content(full_path):
                continue
            relative_path = os.path.relpath(full_path, ".")
            content_parts.append(f"\n\n---\n# {relative_path}\n---\n\n")
            try:
                with open(full_path, "r", encoding="utf-8") as f:
                    content = f.read()
                    content_parts.append(content)
            except Exception as e:
                content_parts.append(f"[Erreur de lecture: {e}]\n")

    combined_text = ''.join(content_parts)

    # 3. Estimation du nombre de tokens
    estimated_tokens = int(len(combined_text) / 4)
    combined_text += f"\n\n---\n# Estimation du nombre de tokens : {estimated_tokens} tokens\n"

    # 4. Sauvegarde
    with open(OUTPUT_FILE, "w", encoding="utf-8") as output:
        output.write(combined_text)

if __name__ == "__main__":
    main()


---
# hacs.json
---

{
  "domain": "urbansolar_battery",
  "name": "Urban Solar Battery",
  "version": "1.0.0",
  "documentation": "https://github.com/chourmovs/ha-urbansolar-bv/wiki",
  "dependencies": [],
  "codeowners": ["@chourmovs"],
  "config_flow": true,
  "requirements": [],
  "iot_class": "local_polling"
}


---
# custom_components/urbansolar_battery/__init__.py
---

"""UrbanSolar Virtual Battery integration."""

import logging

from homeassistant.core import HomeAssistant
from homeassistant.config_entries import ConfigEntry
from .copy_yaml_files import copy_yaml_files

from .const import DOMAIN
from .setup_virtual_battery import setup_virtual_battery

_LOGGER = logging.getLogger(__name__)

async def async_setup(hass: HomeAssistant, config: dict):
    """Set up UrbanSolar Virtual Battery from yaml configuration."""
    return True

async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry):
    """Set up UrbanSolar Virtual Battery from a config entry."""
    _LOGGER.info("Setting up UrbanSolar Virtual Battery integration")
    
    copy_yaml_files()
    hass.data.setdefault(DOMAIN, {})

    # Appelle la fonction pour créer les entités virtuelles
    await setup_virtual_battery(hass)

    return True

async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry):
    """Unload a config entry."""
    _LOGGER.info("Unloading UrbanSolar Virtual Battery integration")

    # Ici on pourrait ajouter du cleanup si nécessaire
    hass.data.pop(DOMAIN, None)

    return True


---
# custom_components/urbansolar_battery/config_flow.py
---

from homeassistant import config_entries
import voluptuous as vol
from homeassistant.core import callback


from .const import DOMAIN, CONF_PRODUCTION_SENSOR, CONF_CONSOMMATION_SENSOR

class VirtualBatteryConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):
    """Config flow for UrbanSolar Virtual Battery."""

    async def async_step_user(self, user_input=None):
        errors = {}
        if user_input is not None:
            return self.async_create_entry(title="UrbanSolar Battery", data=user_input)

        schema = vol.Schema({
            vol.Required(CONF_PRODUCTION_SENSOR): str,
            vol.Required(CONF_CONSOMMATION_SENSOR): str,
        })

        return self.async_show_form(step_id="user", data_schema=schema, errors=errors)

    @staticmethod
    @callback
    def async_get_options_flow(config_entry):
        return VirtualBatteryOptionsFlowHandler(config_entry)

class VirtualBatteryOptionsFlowHandler(config_entries.OptionsFlow):
    """Options flow for UrbanSolar Virtual Battery."""

    def __init__(self, config_entry):
        self._config_entry = config_entry

    async def async_step_init(self, user_input=None):
        if user_input is not None:
            return self.async_create_entry(title="", data=user_input)

        schema = vol.Schema({
            vol.Required(CONF_PRODUCTION_SENSOR, default=self.config_entry.data.get(CONF_PRODUCTION_SENSOR, "")): str,
            vol.Required(CONF_CONSOMMATION_SENSOR, default=self.config_entry.data.get(CONF_CONSOMMATION_SENSOR, "")): str,
        })

        return self.async_show_form(step_id="init", data_schema=schema)


---
# custom_components/urbansolar_battery/const.py
---

DOMAIN = "urbansolar_battery"
CONF_PRODUCTION_SENSOR = "source_energie_produite"
CONF_CONSOMMATION_SENSOR = "source_energie_consommee"

---
# custom_components/urbansolar_battery/copy_yaml_files.py
---

import os
import shutil

BASE_CONFIG_DIR = "/config"
COMPONENT_CONFIG_DIR = os.path.join(os.path.dirname(__file__), "config")

FILES_TO_COPY = ["input_numbers.yaml", "sensors.yaml", "utility_meters.yaml"]

def copy_yaml_files():
    for filename in FILES_TO_COPY:
        src_path = os.path.join(COMPONENT_CONFIG_DIR, filename)
        dest_path = os.path.join(BASE_CONFIG_DIR, filename)

        if not os.path.exists(dest_path):
            shutil.copyfile(src_path, dest_path)
        else:
            # Append the content if not already present (very naïve)
            with open(src_path, "r") as src, open(dest_path, "a") as dest:
                dest.write("\n\n# --- Added by urbansolar_battery ---\n")
                dest.write(src.read())


---
# custom_components/urbansolar_battery/manifest.json
---

{
  "domain": "urbansolar_battery",
  "name": "UrbanSolar Battery",
  "version": "1.0.0",
  "documentation": "https://github.com/chourmovs/ha-urbansolar-bv/wiki",
  "integration_type": "service",
  "requirements": [],
  "dependencies": [],
  "after_dependencies": ["sensor", "utility_meter"],
  "codeowners": ["@chourmovs"],
  "config_flow": true,
  "iot_class": "local_push"
}


---
# custom_components/urbansolar_battery/sensor.py
---

from homeassistant.components.sensor import SensorEntity
from homeassistant.const import ENERGY_KILO_WATT_HOUR

from .const import DOMAIN, CONF_PRODUCTION_SENSOR, CONF_CONSOMMATION_SENSOR

async def async_setup_entry(hass, config_entry, async_add_entities):
    production_sensor = config_entry.data[CONF_PRODUCTION_SENSOR]
    consommation_sensor = config_entry.data[CONF_CONSOMMATION_SENSOR]

    entities = [
        EnergieRestitueeSensor(hass, production_sensor, consommation_sensor),
    ]
    async_add_entities(entities, True)

class EnergieRestitueeSensor(SensorEntity):
    """Sensor to calculate énergie restituée au réseau."""

    def __init__(self, hass, production_sensor, consommation_sensor):
        self.hass = hass
        self.production_sensor = production_sensor
        self.consommation_sensor = consommation_sensor
        self._attr_name = "Énergie Restituée au Réseau"
        self._attr_native_unit_of_measurement = ENERGY_KILO_WATT_HOUR
        self._attr_unique_id = "energie_restituee_au_reseau"

    @property
    def native_value(self):
        production = self._get_state(self.production_sensor)
        consommation = self._get_state(self.consommation_sensor)
        if production is None or consommation is None:
            return None
        return round(production - consommation, 2)

    def _get_state(self, entity_id):
        """Safely retrieve the state of an entity as a float."""
        state = self.hass.states.get(entity_id)
        if state is None or state.state in (None, "unknown", "unavailable"):
            return None
        try:
            return float(state.state)
        except ValueError:
            return None


---
# custom_components/urbansolar_battery/setup_virtual_battery.py
---

import logging
import os
import shutil

_LOGGER = logging.getLogger(__name__)

CONFIG_DIR = "custom_components/urbansolar_battery/config"
TARGET_DIR = "/config"

FILES_TO_COPY = {
    "input_numbers.yaml": "urban_input_numbers.yaml",
    "sensors.yaml": "urban_sensors.yaml",
    "utility_meters.yaml": "urban_utility_meters.yaml",
    "automations.yaml": "urban_automations.yaml",
}

def ensure_fresh_copy(source_file, target_file):
    """Supprime et copie à neuf le fichier si nécessaire."""
    try:
        if os.path.exists(target_file):
            os.remove(target_file)
            _LOGGER.debug(f"Deleted existing file: {target_file}")
        shutil.copy(source_file, target_file)
        _LOGGER.info(f"Copied {source_file} → {target_file}")
    except Exception as e:
        _LOGGER.error(f"Error copying {source_file} to {target_file}: {e}")

async def setup_virtual_battery(hass):
    """Setup the UrbanSolar virtual battery by copying config files."""
    _LOGGER.info("Setting up UrbanSolar Virtual Battery - YAML copy mode")

    for src_name, dest_name in FILES_TO_COPY.items():
        src_path = os.path.join(CONFIG_DIR, src_name)
        dest_path = os.path.join(TARGET_DIR, dest_name)

        if not os.path.exists(src_path):
            _LOGGER.warning(f"Source file does not exist: {src_path}")
            continue

        ensure_fresh_copy(src_path, dest_path)

    _LOGGER.info("UrbanSolar Virtual Battery setup completed.")


---
# custom_components/urbansolar_battery/config/automations.yaml
---

- id: '174508910456'
  alias: Mettre à jour les valeurs de veille et avant-veille
  triggers:
  - at: 00:01:00
    trigger: time
  actions:
  - variables:
      veille: '{{ states(''input_number.energie_restituee_veille'') | float(0) }}'
      aujourd_hui: '{{ states(''sensor.energie_restituee_au_reseau'') | float(0) }}'
  - target:
      entity_id: input_number.energie_restituee_avant_veille
    data:
      value: '{{ veille }}'
    action: input_number.set_value
  - target:
      entity_id: input_number.energie_restituee_veille
    data:
      value: '{{ aujourd_hui }}'
    action: input_number.set_value
  mode: single
- id: '174508910457'
  alias: Mettre à jour Batterie Virtuelle Stock
  triggers:
  - at: 00:01:00
    trigger: time
  actions:
  - choose:
    - conditions:
      - condition: numeric_state
        entity_id: input_number.batterie_virtuelle_pointage
        above: 0
      sequence:
      - target:
          entity_id: input_number.batterie_virtuelle_stock
        data:
          value: '{{ states(''input_number.batterie_virtuelle_pointage'') | float(0)
            }}'
        action: input_number.set_value
      - target:
          entity_id: input_number.batterie_virtuelle_pointage
        data:
          value: 0
        action: input_number.set_value
- id: '174508910473'
  alias: Gestion horaire batterie virtuelle
  triggers:
  - hours: '*'
    minutes: '59'
    seconds: '45'
    trigger: time_pattern
  conditions: []
  actions:
  - variables:
      energie_restituee: '{{ states(''sensor.energie_restituee_au_reseau_hourly'')
        | float(0) }}'
      batterie_stock: '{{ states(''input_number.batterie_virtuelle_stock'') | float(0)
        }}'
      energie_battery_in_hourly: '{{ states(''input_number.energie_battery_in_hourly'')
        | float(0) }}'
      energie_battery_out_hourly: '{{ states(''input_number.energie_battery_out_hourly'')
        | float(0) }}'
  - choose:
    - conditions:
      - condition: numeric_state
        entity_id: sensor.energie_restituee_au_reseau_hourly
        above: 0
      sequence:
      - target:
          entity_id: input_number.energie_battery_in_hourly
        data:
          value: '{{ (energie_battery_in_hourly + energie_restituee) | round(3) }}'
        action: input_number.set_value
    - conditions:
      - condition: numeric_state
        entity_id: sensor.energie_restituee_au_reseau_hourly
        below: 0
      sequence:
      - target:
          entity_id: input_number.energie_battery_out_hourly
        data:
          value: "{%- if batterie_stock > 0 -%}\n  {{ (energie_battery_out_hourly
            + energie_restituee) | round(3) }}\n{%- else -%}\n  0\n{%- endif -%}\n"
        action: input_number.set_value
  - target:
      entity_id: input_number.batterie_virtuelle_stock
    data:
      value: "{{ [\n  0,\n  (\n    batterie_stock\n    + (energie_restituee if energie_restituee
        > 0 else 0)\n    - (\n        energie_restituee | abs\n        if batterie_stock
        > 0 and energie_restituee < 0\n        else 0\n      )\n  )\n] | max | round(3)
        }}\n"
    action: input_number.set_value

---
# custom_components/urbansolar_battery/config/input_numbers.yaml
---

input_number:
  energie_restituee_veille:
    name: Énergie Restituée Veille
    min: 0
    max: 10000
    step: 1
    unit_of_measurement: kWh
    
  energie_battery_in_hourly:
    name: energie battery in hourly
    min: 0
    max: 10000
    step: 1
    unit_of_measurement: kWh    
    
  energie_battery_out_hourly:
    name: energie battery out hourly
    min: -10000
    max: 0
    step: 1
    unit_of_measurement: kWh  

  energie_restituee_avant_veille:
    name: Énergie Restituée Avant-Veille
    min: 0
    max: 100000
    step: 1
    unit_of_measurement: kWh
    
  batterie_virtuelle_pointage:
    name: Batterie Virtuelle Pointage Manuel
    min: 0
    max: 10000
    step: 1
    unit_of_measurement: kWh

  batterie_virtuelle_stock:
    name: Batterie Virtuelle Stock
    min: 0
    max: 10000
    step: 1
    unit_of_measurement: kWh

---
# custom_components/urbansolar_battery/config/lovelace.yaml
---

views:
  - title: "Batterie Virtuelle"
    cards:
      - type: entities
        title: Paramètres Manuels
        entities:
          - entity: input_number.batterie_virtuelle_pointage
          
      - type: markdown
        content: "Pour réinitialiser, cliquez ici : [Réinitialiser la batterie](#/0)"

---
# custom_components/urbansolar_battery/config/sensors.yaml
---

  - platform: template
    sensors:
      diff_energie_restituee_veille_avant_veille:
        friendly_name: "Diff Énergie Restituée Veille - Avant-Veille"
        unit_of_measurement: "kWh"
        value_template: >
          {% set veille = states('input_number.energie_restituee_veille') | float(0) %}
          {% set avant_veille = states('input_number.energie_restituee_avant_veille') | float(0) %}
          {{ veille - avant_veille }}
  
  - platform: template
    sensors:
      batterie_virtuelle_sortie_horaire:
        friendly_name: "Batterie Virtuelle Sortie Horaire"
        unit_of_measurement: "kWh"
        value_template: >
          {% set val = states('input_number.energie_battery_out_hourly') | float(0) %}
          {{ -1 * val }}
  
  - platform: template
    sensors:
      batterie_virtuelle_entre_horaire:
        friendly_name: "Batterie Virtuelle Entrée Horaire"
        unit_of_measurement: "kWh"
        value_template: "{{ states('input_number.energie_battery_in_hourly') | float(0) }}"


---
# custom_components/urbansolar_battery/config/utility_meters.yaml
---

utility_meter:
  energie_restituee_au_reseau_hourly:
    source: sensor.energie_restituee_au_reseau
    cycle: hourly
    net_consumption: true

---
# custom_components/urbansolar_battery/translations/fr.json
---

{
  "config": {
    "step": {
      "user": {
        "title": "Configurer la Batterie Virtuelle Urban Solar",
        "description": "Sélectionnez les capteurs de production et consommation."
      }
    }
  },
  "options": {
    "step": {
      "init": {
        "title": "Options de la Batterie Virtuelle"
      }
    }
  }
}


---
# Estimation du nombre de tokens : 4434 tokens
